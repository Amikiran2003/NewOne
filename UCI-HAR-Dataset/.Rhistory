}
get <- function() x
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## This function computes the inverse of the special "matrix" returned by `makeCacheMatrix` above. If the inverse has
##already been calculated (and the matrix has not changed), then `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
inverse <- x$getinv()
if(!is.null(inverse)){
message("Getting cache data:")
return(inverse)
}
data <- x$get()
inverse <- solve(data)
x$setinv(inverse)
return(inverse)
}
x <- makeCacheMatrix()
x$get()
cacheSolve(x)
size < 100
size < 100
makeCacheMatrix <- function(nrow = sample(5:10, 1),
ncol = sample(5:10, 1),
x = sample(1:100),, 15120, replace = T )) {
matrix(data, nrow, ncol)
}
matrix(data, nrow, ncol)
makeCacheMatrix <- function(nrow = sample(5:10, 1),
ncol = sample(5:10, 1),
x = sample(1:100),, 15120, replace = T ))
{
matrix(x, nrow, ncol)
}
makeCacheMatrix <- function(nrow = sample(5:10, 1),
ncol = sample(5:10, 1),
x = sample(1:100), 15120, replace = T ))
{
matrix(x, nrow, ncol)
}
makeCacheMatrix <- function(nrow = sample(5:10, 1),
ncol = sample(5:10, 1),
x = sample(1:100), 15120, replace = T )
{
matrix(x, nrow, ncol)
}
makeCacheMatrix <- function(nrow = sample(5:10, 1),
ncol = sample(5:10, 1),
data = sample(1:100), 15120, replace = T )
{
matrix(data, nrow, ncol)
}
makeCacheMatrix <- function(nrow = sample(5:10, 1),
ncol = sample(5:10, 1),
data = sample(1:100), 15120, replace = T ) )
{
matrix(data, nrow, ncol)
}
makeCacheMatrix <- function(x = matrix((rnorm(size^2), nrow = size, ncol = size)) {
size <- 100
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
cacheSolve <- function(x, ...) {
inverse <- x$getinv()
if(!is.null(inverse)){
message("Getting cache data:")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinv(inverse)
return(inverse)
}
makeCacheMatrix(100, 3,3)
makeCacheMatrix(100)
makeCacheMatrix(1:100)
makeCacheMatrix()
x <- makeCacheMatrix(1:100)
x$get
x$get()
x <- makeCacheMatrix(1:100, 3, 3)
size <- 100
mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
mymatrix(100, 3,3)
size <- 100
mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
x <- matrix(1:100, 4,4)
x$get()
x()
matrix
matrix()
matrix(1:100, 4,4)
matrix(1:100, 10,10)
size <- 100
##mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
x = matrix((rnorm(size^2), nrow = size, ncol = size)
size <- 100
##mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
matrix((rnorm(size^2), nrow = size, ncol = size)
size <- 100,
##mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
matrix((rnorm(size^2), nrow = size, ncol = size)
size <- 100
##mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
matrix(rnorm(size), nrow = size, ncol = size)
size <- 10
##mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
matrix(rnorm(size), nrow = size, ncol = size)
size <- 5
##mymatrix <- matrix(rnorm(size^2), nrow = size, ncol = size)
matrix(rnorm(size), nrow = size, ncol = size)
makeCacheMatrix <- function( matrix(, nrow = 3, ncol =3)) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## This function computes the inverse of the special "matrix" returned by `makeCacheMatrix` above. If the inverse has
##already been calculated (and the matrix has not changed), then `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
inverse <- x$getinv()
if(!is.null(inverse)){
message("Getting cache data:")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinv(inverse)
return(inverse)
}
x <- makeCacheMatrix(1:9,3,3)
makeCacheMatrix <- function( x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## This function computes the inverse of the special "matrix" returned by `makeCacheMatrix` above. If the inverse has
##already been calculated (and the matrix has not changed), then `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
inverse <- x$getinv()
if(!is.null(inverse)){
message("Getting cache data:")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinv(inverse)
return(inverse)
}
x <- makeCacheMatrix()
x$set(matrix(1:9, 3,3))
cacheSolve(x)
x$set(matrix(1:9, 3,3))
x$get()
cacheSlove(x)
cacheSolve(x)
x$set(matrix(1:4, 3,3))
x$set(matrix(1:4, 32,2))
x$set(matrix(1:4, 2,2))
matrix <- x$get()
matrix
cacheSolve()
cacheSolve(x)
x$set(matrix(1:9, 3,3))
matrix <- x$get()
matrix
cacheSolve(x)
cacheSolve(matrix)
x$set(matrix(1:9, 3,3))
matrix <- x$get()
cacheSolve(x)
m <- matrix(x = c(9,8,7,6,5,4,3,2,1), nrow = 3, ncol =3)
m <- matrix(x = c(9,8,7,6), nrow = 2, ncol =2)
x$set(matrix(1:4, 2,2))
x$get()
cacheSolve(x)
x$set(matrix(9:18, 3 , 3))
x$set(matrix(9:18, 3, 3))
x$set(matrix(1:9, 3, 3))
x$get
x$get()
cacheSolve(x)
det(matrix(1:9, 3, 3))
det(matrix(c(1:8, 10), 3, 3))
det(matrix(c(1:9, 10), 3, 3))
det(matrix(c(1:8, 10), 3, 3))
x$set(matrix(c(1:8, 10), 3, 3))
x$get()
cacheSolve(x)
det(matrix(rnorm(1:8, 10), 3, 3))
x$set(matrix(c(1:16, 10), 4, 4))
x$set(matrix(c(1:16), 4, 4))
det(matrix(c(1:16), 4, 4))
x$set(matrix(c(1:16), 4, 4))
x$get()
cacheSolve(x)
det(matrix(c(1:15, 16), 4, 4))
det(matrix(c(1:15, 17), 4, 4))
det(matrix(c(1:14, 17), 4, 4))
det(matrix(c(1:15, 18), 4, 4))
det(matrix(c(1:15, 19), 4, 4))
det(matrix(c(1:15, 20), 4, 4))
det(matrix(c(1:15, 21), 4, 4))
det(matrix(c(1:15, 22), 4, 4))
det(matrix(c(1:15, 23), 4, 4))
det(matrix(rnorm(), 23), 4, 4))
det(matrix(rnorm(), 4, 4))
det(matrix(rnorm(100), 4, 4))
set$(matrix(rnorm(100), 4, 4))
x$set(matrix(rnorm(100), 4, 4))
x$get()
cacheSolve(x)
x$set(matrix(rnorm(100), 4, 5))
x$get()
cacheSolve(x)
x$set(matrix(rnorm(100), 5, 5))
x$get()
cacheSolve(x)
x$set(matrix(rnorm(100), 5, 5))
cacheSolve(x)
cacheSolve(x)
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
nverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## This function computes the inverse of the special "matrix" returned by `makeCacheMatrix` above. If the inverse has
##already been calculated (and the matrix has not changed), then `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
inverse <- x$getinv()
if(!is.null(inverse)){
message("Getting cache data:")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinv(inverse)
return(inverse)
}
x$set(matrix(rnorm(100), nrow = 2, ncol =2))
x$get()
cacheSolve(x)
x$set(matrix(rnorm(100), nrow = 5, ncol =5))
x$get()
cacheSolve(x)
cacheSolve(x)
## This function creates a special "matrix" object that can cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
inverse <- NULL
set <- function(y) {
x <<- y
inverse <<- NULL
}
get <- function() x
setinv <- function(inv) inverse <<- inv
getinv <- function() inverse
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## This function computes the inverse of the special "matrix" returned by `makeCacheMatrix` above. If the inverse has
##already been calculated (and the matrix has not changed), then `cacheSolve` should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getinv()
if(!is.null(inverse)){
message("Getting cache data:")
return(inverse)
}
data <- x$get()
inverse <- solve(data, ...)
x$setinv(inverse)
return(inverse)
}
x$set(matrix(rnorm(100), nrow = 4, ncol =4))
x$get()
cacheSolve(x)
cacheSolve(x)
library(XML)
install.packages("XML")
library(XML)
fileUrl <- "http://www.w3schools.com/xml/simple.xml"
doc <- xmlTreeParse(fileUrl, useInternet = TURE)
doc <- xmlTreeParse(fileUrl, useInternet = TRUE)
doc <- xmlTreeParse(fileUrl, useInternal = TRUE)
rootNode <- xmlRoot(doc)
xmlName(rootNode)
names(rootNode)
rootNode[[1]]
rootNode[[1]][[1]]
xmlSApply(rootNode, xmlValue)
xmlSApply(rootNode, "//name",xmlValue)
xmlSApply(rootNode, "//name", xmlValue)
xmlSApply(rootNode,"//name", xmlValue)
xmlSApply(rootNode,"//price", xmlValue)
xpathSApply(rootNode,"//price", xmlValue)
xmpathSApply(rootNode,"//name", xmlValue)
xpathSApply(rootNode,"//name", xmlValue)
library(RMySQL)
install.packages("DBI")
library(RMySQL)
library(RMySQL)
install.packages("RMySQL", type="source")
dbh <- dbConnect(MySQK(), user="Amita", password="gotodata768$", host="127.0.0.1")
dbh <- dbConnect(MySQL(), user="Amita", password="gotodata768$", host="127.0.0.1")
library(RMySQL)
install.packages("DBI")
library(RMySQL)
dbh <- dbConnect(MySQL(), user="Amita", password="gotodata768$", host="127.0.0.1")
result <-dbGetQuery(dbh, "show databases;") dbDisconnect(dbh)
result <-dbGetQuery(dbh, "show databases;"); dbDisconnect(dbh)
result
uscsDb <- dbCOnnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
library(RMySQL)
uscsDb <- dbCOnnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
install.packages("sqldf")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu-A")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
dbh <- dbConnect(MySQL(), user="Amita", password="gotodata768$", host="127.0.0.1")
library("sqldf", lib.loc="~/R/win-library/3.1")
install.packages("sqldf")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", password="password" host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", password="password", host="genome-mysql.cse.uscs.edu")
library("sqldf", lib.loc="~/R/win-library/3.1")
uscsDb <- dbConnect(MySQL(), user="genome", password="password", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", password="password", host="localhost")
uscsDb <- dbConnect(MySQL(), user="genome", password="password", host="127.0.0.1")
uscsDb <- dbConnect(MySQL(), user="genome", host="127.0.0.1")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.uscs.edu")
uscsDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(uscsDb, "show databases;"); dbDiscoonect(uscsDb);
result <- dbGetQuery(uscsDb, "show databases;"); dbDisconnect(uscsDb);
result
hg19 <- dbConnect(MySQL(), user="genome", db="hg19", host="genome-mysql.cse.ucsc.edu")
alltables <-dbListTables(hg19)
lenght(allTables)
length(allTables)
length(alltables)
alltable[1:5]
alltables[1:5]
dbListFields(hg19, "HInvv")
dbListFields(hg19, "HInv")
dbGetQuery(hg19, "select count(*) from HInv")
HInv <- dbReadTable(hg19, "HInv")
head(HInv)
query <- dbSendQuery(hg19, "select * from HInv where misMatch between 1 and 3")
query <- dbSendQuery(hg19, "select * from HInv where geneID between 1 and 3")
HI <- fetch(query); quantile(HI$geneID)
dbDisconnect(hg19)
q()
library("RMySQL", lib.loc="~/R/win-library/3.1")
install.packages("RMySQL")
install.packages("RMySQL")
install.packages("RMySQL")
install.packages("RMySQL")
install.packages(c("colorspace", "digest", "manipulate", "RColorBrewer", "Rcpp", "reshape2"))
library("RMySQL", lib.loc="~/R/win-library/3.1")
install.packages("RMySQL")
install.packages("RMySQL")
install.packages("RMySQL")
install.packages("RMySQL")
library("RMySQL", lib.loc="~/R/win-library/3.1")
library("DBI", lib.loc="~/R/win-library/3.1")
source("http://biconductor.org/biocLite.R")
source("http://www.bioconductor.org/biocLite.R")
source("http://bioconductor.org/biocLite.R")
source("http://bioconductor.org/biocLite.R")
biocLite()
install(sqldf)
library(sqldf)
acs <- read.csv("./getdata-data-ss06pid.csv", header = T, sep = ",")
acs <- read.csv("getdata-data-ss06pid.csv", header = T, sep = ",")
getwd()
setwd("C:/R)
/)
)
)""
)
,.sm,m
q()
...
setwd("C:/R")
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv"
file <- file.path(getwd(), "EDSTATS_Country.csv")
download.file(url, file, method = "curl")
download.file(url, file, method = "internal")
dtEd <- data.table(read.csv(file))
library("data.table", lib.loc="~/R/win-library/3.1")
install.packages(c("ggplot2", "jsonlite", "manipulate", "mime"))
dtEd <- data.table(read.csv(file))
dt <- merge(dtGDP, dtEd, all = TRUE, by = c("CountryCode"))
> url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
> file <- file.path(getwd(), "GDP.csv")
> download.file(url, file, method = "curl")
> dtGDP <- data.table(read.csv(file, skip = 4, nrows = 215, stringsAsFactors = FALSE))
> dtGDP <- dtGDP[X != ""]
> dtGDP <- dtGDP[, list(X, X.1, X.3, X.4)]
> setnames(dtGDP, c("X", "X.1", "X.3", "X.4"), c("CountryCode", "rankingGDP", "Long.Name", "gdp"))
> gdp <- as.numeric(gsub(",", "", dtGDP$gdp))
> mean(gdp, na.rm = TRUE)
setwd("C:/R")
> url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
file <- file.path(getwd(), "GDP.csv")
download.file(url, file, method = "internal")
dtGDP <- data.table(read.csv(file, skip = 4, nrows = 215, stringsAsFactors = FALSE))
dtGDP <- dtGDP[X != ""]
dtGDP <- dtGDP[, list(X, X.1, X.3, X.4)]
setnames(dtGDP, c("X", "X.1", "X.3", "X.4"), c("CountryCode", "rankingGDP", "Long.Name", "gdp"))
gdp <- as.numeric(gsub(",", "", dtGDP$gdp))
gdp <- as.numeric(gsub(",", "", dtGDP$gdp))
mean(gdp, na.rm = TRUE)
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv"
file <- file.path(getwd(), "EDSTATS_Country.csv")
download.file(url, file, method = "internal")
dtEd <- data.table(read.csv(file))
dt <- merge(dtGDP, dtEd, all = TRUE, by = c("CountryCode"))
isFiscalYearEnd <- grepl("fiscal year end", tolower(dt$Special.Notes))
isJune <- grepl("june", tolower(dt$Special.Notes))
table(isFiscalYearEnd, isJune)
amzn <- getSymbols("AMZN", auto.assign = FALSE)
library(quantmod)
install.packages("quantmod")
library("quantmod", lib.loc="~/R/win-library/3.1")
amzn <- getSymbols("AMZN", auto.assign = FALSE)
library(quantmod)
amzn <- getSymbols("AMZN", auto.assign = FALSE)
sampleTimes <- index(amzn)
addmargins(table(year(sampleTimes), weekdays(sampleTimes)))
url <- "https://d396qusza40orc.cloudfront.net/getdata%2Fprojectfiles%2FUCI%20HAR%20Dataset.zip "
file <- file.path(getwd(), "Dataset.zip")
download.file(url, file, method = "internal")
tmp1 <- read.table("train/X_train.txt")
getwd()
tmp1 <- read.table("UCI HAR Dataset/train/X_train.txt")
tmp2 <- read.table("UCI HAR Dataset/test/X_test.txt")
X <- rbind(tmp1, tmp2)
X
head(X)
tmp1 <- read.table("UCI HAR Dataset/train/subject_train.txt")
tmp1 <- read.table("UCI HAR Dataset/train/subject_train.txt")
tmp2 <- read.table("UCI HAR Dataset/test/subject_test.txt")
S <- rbind(tmp1, tmp2)
head(S)
tmp1 <- read.table("UCI HAR Dataset/train/y_train.txt")
tmp2 <- read.table("UCI HAR Dataset/test/y_test.txt")
Y <- rbind(tmp1, tmp2)
head(Y)
features <- read.table("features.txt")
features <- read.table("UCI HAR Dataset/features.txt")
setwd("C:/R/UCI HAR Dataset")
features <- read.table("features.txt")
indices_of_good_features <- grep("-mean\\(\\)|-std\\(\\)", features[, 2])
X <- X[, indices_of_good_features]
names(X) <- features[indices_of_good_features, 2]
names(X) <- gsub("\\(|\\)", "", names(X))
names(X) <- tolower(names(X))
activities <- read.table("activity_labels.txt")
activities[, 2] = gsub("_", "", tolower(as.character(activities[, 2])))
Y[,1] = activities[Y[,1], 2]
names(Y) <- "activity"
names(S) <- "subject"
cleaned <- cbind(S, Y, X)
write.table(cleaned, "merged_clean_data.txt")
uniqueSubjects = unique(S)[,1]
numSubjects = length(unique(S)[,1])
numActivities = length(activities[,1])
numCols = dim(cleaned)[2]
result = cleaned[1:(numSubjects*numActivities), ]
row = 1
for (s in 1:numSubjects) {
for (a in 1:numActivities) {
result[row, 1] = uniqueSubjects[s]
result[row, 2] = activities[a, 2]
tmp <- cleaned[cleaned$subject==s & cleaned$activity==activities[a, 2], ]
result[row, 3:numCols] <- colMeans(tmp[, 3:numCols])
row = row+1
}
}
write.table(result, "data_set_with_the_averages.txt")
write.table(result, "data_set_with_the_averages.txt", row.name = FALSE)
